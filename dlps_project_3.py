# -*- coding: utf-8 -*-
"""dlps-project_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1padvWEcweoNH_dR4-mc0UyoToYoGzgnh
"""

!pip install -U -q PyDrive
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

file_id = '11c_HhAyF2hqrOcdtTnwB0G90vqIsyuUz'
downloaded = drive.CreateFile({'id': file_id})

downloaded.GetContentFile('RUL_training-data.xlsx')

!pip install -q xlrd

import pandas as pd
df = pd.read_excel('RUL_training-data.xlsx')

# we import required libraries
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import sklearn
from sklearn.metrics import classification_report
from sklearn import metrics

x_input = df.to_numpy()

#------------------------------------------------

time = []
#time array is the collection of life of all engine times 
indice = []

for i in range(0, x_input.shape[0]-1):
  if x_input[i][0] != x_input[i+1][0]:
    time.append(x_input[i][1])
    indice.append(i)
  else:
    continue

time.append(x_input[x_input.shape[0]-1][1])
indice.append(x_input.shape[0]-1)

time = np.array(time)
indice = np.array(indice)

#time.shape should give number of engines i.e. 133

#-------------------------------------------------
y_train = []

#array y gives RUL - Remaining Useful Life corresponding to each row in x

j = 0
for i in range(0, x_input.shape[0]):
  y_train.append(time[j] - x_input[i][1])
  if time[j] == x_input[i][1]:
    j = j+1

y_train = np.array(y_train)

#----------------------------------------------
x_train = np.delete(x_input, 0, 1)

#----------------------------------------------
file_id = '1l_jOjgrQNVipZsRgSTHd0Qf81oloHmTX'
downloaded = drive.CreateFile({'id': file_id})

downloaded.GetContentFile('RUL_testing-data.xlsx')

df2 = pd.read_excel('RUL_testing-data.xlsx')
x_input2 = df2.to_numpy()
#----------------------------------------------

time2 = []
indice2 = []

for i in range(0, x_input2.shape[0]-1):
  if x_input2[i][0] != x_input2[i+1][0]:
    time2.append(x_input2[i][1])
    indice2.append(i)
  else:
    continue

time2.append(x_input2[x_input2.shape[0]-1][1])
indice2.append(x_input2.shape[0]-1)

time2 = np.array(time2)
indice2 = np.array(indice2)

#-------------------------------------------
y_test = []

#array y gives RUL - Remaining Useful Life corresponding to each row in x

j = 0
for i in range(0, x_input2.shape[0]):
  y_test.append(time2[j] - x_input2[i][1])
  if time2[j] == x_input2[i][1]:
    j = j+1

y_test = np.array(y_test)

#-----------------------------------------

x_test = np.delete(x_input2, 0, 1)
#----------------------------------------

from sklearn.decomposition import PCA

pca = PCA(n_components=3)
pca.fit(x_train[1:])
x_train_pca = pca.transform(x_train)
x_test_pca = pca.transform(x_test)

#---------------------------------------

def get_cmap(n, name='hsv'):
    return plt.cm.get_cmap(name, n)

cmap = get_cmap(218)

#----------------------------------------
k = 0
y_target = np.zeros([x_input.shape[0] ,1])
for i in range(0, x_input.shape[0]):
  y_target[i] = 1 - (x_input[i][1] / time[k])
  if time[k] == x_input[i][1]:
    k = k+1

#ad_mat = np.ones([x_input.shape[0] ,1])
feature_mat = np.zeros([x_input.shape[0] ,3])

for i in range(0, x_input.shape[0]):
  #s16 column 21
  #feature_mat[i][0] = x_input[i][20]
  #s11 column 16
  feature_mat[i][0] = x_input[i][15]
  #s2 column 7
  feature_mat[i][1] = x_input[i][6]
  #s15 column 20
  feature_mat[i][2] = x_input[i][19]


#weights = np.dot(np.dot(np.linalg.inv(np.dot(feature_mat.T, feature_mat)), feature_mat.T), y_target)
from sklearn.linear_model import LinearRegression
reg = LinearRegression().fit(feature_mat, y_target)
weights = reg.coef_

weights = weights.T

engine_health = np.zeros([x_input.shape[0], 1])

for i in range(0, x_input.shape[0]):
  engine_health[i][0] = (weights[0]*x_input[i][15]) + (weights[1]*x_input[i][6]) + (weights[2]*x_input[i][19]) + reg.intercept_


#output matrix tyaar for linear reg
#----------------------------------------

engine_health_train = np.zeros([x_input.shape[0], 1])
#engine_health_train quadratic best fit curves hai

for k in range(0, 217):
  if k==0:
    cc = np.polyfit(x_input[0:indice[0], 1], engine_health[0:indice[0], 0], 2)
    engine_health_train[0:indice[0], 0] = cc[0]*x_input[0:indice[0], 1]**2 + cc[1]*x_input[0:indice[0], 1] + cc[2]
  cc = np.polyfit(x_input[indice[k]+1:indice[k+1], 1], engine_health[indice[k]+1:indice[k+1], 0], 2)
  engine_health_train[indice[k]+1:indice[k+1], 0] = cc[0]*x_input[indice[k]+1:indice[k+1], 1]**2 + cc[1]*x_input[indice[k]+1:indice[k+1], 1] + cc[2]

#engine_health_train best fit curves ka matrix hai
#----------------------------------------------------------

#testing data ka engine_health_test matrix:
engine_health_test = np.zeros([x_input2.shape[0], 1])

for i in range(0, x_input2.shape[0]):
  engine_health_test[i][0] = (weights[0]*x_input2[i][15]) + (weights[1]*x_input2[i][6]) + (weights[2]*x_input2[i][19]) + reg.intercept_

#----------------------------------------------------------

for k in range(0, 217):
  if k==0:
    plt.plot(x_input[0:indice[0], 1], engine_health_train[0:indice[0] ,0], c=cmap(100))
  plt.plot(x_input[indice[k]+1:indice[k+1], 1], engine_health_train[indice[k]+1:indice[k+1] ,0], c=cmap(100))

plt.xlabel("Cycles")
plt.ylabel("Engine Health")

plt.plot(x_input2[indice2[3]+1:indice2[4], 1], engine_health_test[indice2[3]+1:indice2[4], 0], c=cmap(0))

start = indice2[3]+1
end = indice2[4]
#the above values are for 5th engine in test data
all_cycles = []

for j in range(start+1, end):
  avg_dist = []
  dist = []

  for k in range(0, 217):
    if k==0:
      dist = []
      for i in range(0, j-start):
        d  = np.sqrt(np.power(engine_health_train[i, 0] - engine_health_test[i+start, 0] ,2 ))
        dist.append(d)
      avg_dist.append(np.mean(dist))
    dist = []
    for i in range(indice[k]+1, indice[k]+1 + j-start):
      if(i>=45918):
        continue
      d  = np.sqrt(np.power(engine_health_train[i, 0] - engine_health_test[i+start - (indice[k]+1), 0] ,2 ))
      dist.append(d)
    avg_dist.append(np.mean(dist))

  avg_dist = np.array(avg_dist)
  #-----------------------------
  temp_arr = np.zeros([218, 1])

  for i in range(0, 218):
    temp_arr[i] = avg_dist[i]

  temp_arr.sort(axis=0)

  engine_number = []
  for i in range(0, 10):
    ak = np.where(avg_dist == temp_arr[i])
    ak = np.array(ak)
    engine_number.append(np.asscalar(ak))

  engine_number = np.array(engine_number)

  final_rul = []
  for i in range(0, 10):
    final_rul.append(time[engine_number[i]])

  final_rul = np.array(final_rul)
  ans = np.median(final_rul)
  print("time =", j-start, "cycles ","predicted life = ",ans,"cycles ", " ","original life = ", x_input2[indice2[4], 1],"cycles ")
  all_cycles.append(ans)

all_cycles = np.array(all_cycles)
print(np.mean(all_cycles))

x_ax = np.linspace(1, 216, 216)
y_ax = np.linspace(218, 218, 216)
plt.plot(x_ax, y_ax, c = cmap(100))
plt.plot(x_ax, all_cycles, c = cmap(0))
plt.xlabel("Cycles")
plt.ylabel("Final Engine Life: original vs predicted")

mean_ans_array = []
for itr in range(0, 217):
  
  start = indice2[itr]+1
  end = indice2[itr+1]

  all_cycles = []

  for j in range(start+1, end):
    avg_dist = []
    dist = []

    for k in range(0, 217):
      if k==0:
        dist = []
        for i in range(0, j-start):
          d  = np.sqrt(np.power(engine_health_train[i, 0] - engine_health_test[i+start, 0] ,2 ))
          dist.append(d)
        avg_dist.append(np.mean(dist))
      dist = []
      for i in range(indice[k]+1, indice[k]+1 + j-start):
        if(i>=45918):
          continue
        d  = np.sqrt(np.power(engine_health_train[i, 0] - engine_health_test[i+start - (indice[k]+1), 0] ,2 ))
        dist.append(d)
      avg_dist.append(np.mean(dist))

    avg_dist = np.array(avg_dist)
    #-----------------------------
    temp_arr = np.zeros([218, 1])

    for i in range(0, 218):
      temp_arr[i] = avg_dist[i]

    temp_arr.sort(axis=0)

    engine_number = []
    for i in range(0, 10):
      ak = np.where(avg_dist == temp_arr[i])
      ak = np.array(ak)
      engine_number.append(np.asscalar(ak))

    engine_number = np.array(engine_number)

    final_rul = []
    for i in range(0, 10):
      final_rul.append(time[engine_number[i]])

    final_rul = np.array(final_rul)
    ans = np.median(final_rul)
    #print("time =", j-start, "cycles ","predicted life = ",ans,"cycles ", " ","original life = ", x_input2[indice2[4], 1],"cycles ")
    all_cycles.append(ans)

  all_cycles = np.array(all_cycles)
  variable = np.mean(all_cycles)
  mean_ans_array.append(variable)
  print(itr, "iteration completed")

mean_ans_array = np.array(mean_ans_array)

for i in range(0, 10):
  print("engine number =", i+2,"predicted life =",mean_ans_array[i], "original life =", x_input2[indice2[i+1], 1])